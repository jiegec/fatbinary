//! Rust bindings for NVIDIA's nvFatbin library.
//!
//! This crate provides a safe wrapper around nvFatbin.
//! It allows creation of fatbinaries containing PTX, cubins, LTOIR, and other components.

#![allow(nonstandard_style)]

use std::ffi::{CStr, CString};
use std::ptr;
use thiserror::Error;

// Include the raw C bindings generated by bindgen.
include!(concat!(env!("OUT_DIR"), "/bindings.rs"));

/// Error type for fatbin operations.
#[derive(Debug, Error)]
pub enum FatbinError {
    /// Internal error in the fatbin library.
    #[error("internal fatbin error")]
    Internal,
    /// ELF architecture mismatch.
    #[error("ELF architecture mismatch")]
    ElfArchMismatch,
    /// ELF size mismatch.
    #[error("ELF size mismatch")]
    ElfSizeMismatch,
    /// Missing PTX version.
    #[error("missing PTX version")]
    MissingPtxVersion,
    /// Null pointer passed to API.
    #[error("null pointer passed to API")]
    NullPointer,
    /// Compression failed.
    #[error("compression failed")]
    CompressionFailed,
    /// Compressed size exceeded limit.
    #[error("compressed size exceeded limit")]
    CompressedSizeExceeded,
    /// Unrecognized option.
    #[error("unrecognized option")]
    UnrecognizedOption,
    /// Invalid architecture string.
    #[error("invalid architecture")]
    InvalidArch,
    /// Invalid NVVM.
    #[error("invalid NVVM")]
    InvalidNvvm,
    /// Empty input.
    #[error("empty input")]
    EmptyInput,
    /// Missing PTX architecture.
    #[error("missing PTX architecture")]
    MissingPtxArch,
    /// PTX architecture mismatch.
    #[error("PTX architecture mismatch")]
    PtxArchMismatch,
    /// Missing fatbin.
    #[error("missing fatbin")]
    MissingFatbin,
    /// Invalid index.
    #[error("invalid index")]
    InvalidIndex,
    /// Identifier reuse.
    #[error("identifier reuse")]
    IdentifierReuse,
    /// Unknown error code.
    #[error("unknown error code: {0}")]
    Unknown(i32),
}

impl From<nvFatbinResult> for FatbinError {
    fn from(result: nvFatbinResult) -> Self {
        match result {
            nvFatbinResult_NVFATBIN_SUCCESS => panic!("cannot convert success to error"),
            nvFatbinResult_NVFATBIN_ERROR_INTERNAL => FatbinError::Internal,
            nvFatbinResult_NVFATBIN_ERROR_ELF_ARCH_MISMATCH => FatbinError::ElfArchMismatch,
            nvFatbinResult_NVFATBIN_ERROR_ELF_SIZE_MISMATCH => FatbinError::ElfSizeMismatch,
            nvFatbinResult_NVFATBIN_ERROR_MISSING_PTX_VERSION => FatbinError::MissingPtxVersion,
            nvFatbinResult_NVFATBIN_ERROR_NULL_POINTER => FatbinError::NullPointer,
            nvFatbinResult_NVFATBIN_ERROR_COMPRESSION_FAILED => FatbinError::CompressionFailed,
            nvFatbinResult_NVFATBIN_ERROR_COMPRESSED_SIZE_EXCEEDED => {
                FatbinError::CompressedSizeExceeded
            }
            nvFatbinResult_NVFATBIN_ERROR_UNRECOGNIZED_OPTION => FatbinError::UnrecognizedOption,
            nvFatbinResult_NVFATBIN_ERROR_INVALID_ARCH => FatbinError::InvalidArch,
            nvFatbinResult_NVFATBIN_ERROR_INVALID_NVVM => FatbinError::InvalidNvvm,
            nvFatbinResult_NVFATBIN_ERROR_EMPTY_INPUT => FatbinError::EmptyInput,
            nvFatbinResult_NVFATBIN_ERROR_MISSING_PTX_ARCH => FatbinError::MissingPtxArch,
            nvFatbinResult_NVFATBIN_ERROR_PTX_ARCH_MISMATCH => FatbinError::PtxArchMismatch,
            nvFatbinResult_NVFATBIN_ERROR_MISSING_FATBIN => FatbinError::MissingFatbin,
            nvFatbinResult_NVFATBIN_ERROR_INVALID_INDEX => FatbinError::InvalidIndex,
            nvFatbinResult_NVFATBIN_ERROR_IDENTIFIER_REUSE => FatbinError::IdentifierReuse,
            _ => FatbinError::Unknown(result as i32),
        }
    }
}

impl FatbinError {
    /// Get the error description string from the library.
    pub fn description(&self) -> Option<&'static str> {
        let code = match self {
            FatbinError::Internal => nvFatbinResult_NVFATBIN_ERROR_INTERNAL,
            FatbinError::ElfArchMismatch => nvFatbinResult_NVFATBIN_ERROR_ELF_ARCH_MISMATCH,
            FatbinError::ElfSizeMismatch => nvFatbinResult_NVFATBIN_ERROR_ELF_SIZE_MISMATCH,
            FatbinError::MissingPtxVersion => nvFatbinResult_NVFATBIN_ERROR_MISSING_PTX_VERSION,
            FatbinError::NullPointer => nvFatbinResult_NVFATBIN_ERROR_NULL_POINTER,
            FatbinError::CompressionFailed => nvFatbinResult_NVFATBIN_ERROR_COMPRESSION_FAILED,
            FatbinError::CompressedSizeExceeded => {
                nvFatbinResult_NVFATBIN_ERROR_COMPRESSED_SIZE_EXCEEDED
            }
            FatbinError::UnrecognizedOption => nvFatbinResult_NVFATBIN_ERROR_UNRECOGNIZED_OPTION,
            FatbinError::InvalidArch => nvFatbinResult_NVFATBIN_ERROR_INVALID_ARCH,
            FatbinError::InvalidNvvm => nvFatbinResult_NVFATBIN_ERROR_INVALID_NVVM,
            FatbinError::EmptyInput => nvFatbinResult_NVFATBIN_ERROR_EMPTY_INPUT,
            FatbinError::MissingPtxArch => nvFatbinResult_NVFATBIN_ERROR_MISSING_PTX_ARCH,
            FatbinError::PtxArchMismatch => nvFatbinResult_NVFATBIN_ERROR_PTX_ARCH_MISMATCH,
            FatbinError::MissingFatbin => nvFatbinResult_NVFATBIN_ERROR_MISSING_FATBIN,
            FatbinError::InvalidIndex => nvFatbinResult_NVFATBIN_ERROR_INVALID_INDEX,
            FatbinError::IdentifierReuse => nvFatbinResult_NVFATBIN_ERROR_IDENTIFIER_REUSE,
            FatbinError::Unknown(_) => return None,
        };
        let cstr = unsafe { nvFatbinGetErrorString(code) };
        if cstr.is_null() {
            None
        } else {
            unsafe { CStr::from_ptr(cstr).to_str().ok() }
        }
    }
}

type Result<T> = std::result::Result<T, FatbinError>;

/// A handle to a fatbin being constructed.
///
/// This struct owns the underlying `nvFatbinHandle` and ensures proper cleanup.
pub struct Fatbin {
    handle: nvFatbinHandle,
}

impl Fatbin {
    /// Create a new fatbin with the given options.
    ///
    /// Options are passed as an array of strings, each containing a single option
    /// as described in the NVIDIA nvFatbin documentation.
    pub fn new(options: &[&str]) -> Result<Self> {
        let c_options: Vec<CString> = options
            .iter()
            .map(|s| CString::new(*s).map_err(|_| FatbinError::NullPointer))
            .collect::<std::result::Result<Vec<_>, _>>()?;
        let mut ptrs: Vec<*const libc::c_char> = c_options.iter().map(|s| s.as_ptr()).collect();
        let mut handle: nvFatbinHandle = ptr::null_mut();
        let result =
            unsafe { nvFatbinCreate(&mut handle, ptrs.as_mut_ptr(), ptrs.len() as libc::size_t) };
        if result == nvFatbinResult_NVFATBIN_SUCCESS {
            Ok(Fatbin { handle })
        } else {
            Err(FatbinError::from(result))
        }
    }

    /// Add PTX code to the fatbin.
    ///
    /// # Arguments
    /// * `code` - PTX source code as a string.
    /// * `arch` - Target architecture (e.g., "75").
    /// * `identifier` - Name for this PTX entry.
    /// * `options_cmd_line` - Compilation options (can be empty string).
    pub fn add_ptx(
        &mut self,
        code: &str,
        arch: &str,
        identifier: &str,
        options_cmd_line: &str,
    ) -> Result<()> {
        let code_c = CString::new(code).map_err(|_| FatbinError::NullPointer)?;
        let arch_c = CString::new(arch).map_err(|_| FatbinError::NullPointer)?;
        let ident_c = CString::new(identifier).map_err(|_| FatbinError::NullPointer)?;
        let opts_c = CString::new(options_cmd_line).map_err(|_| FatbinError::NullPointer)?;
        let result = unsafe {
            nvFatbinAddPTX(
                self.handle,
                code_c.as_ptr(),
                code_c.as_bytes().len(),
                arch_c.as_ptr(),
                ident_c.as_ptr(),
                opts_c.as_ptr(),
            )
        };
        if result == nvFatbinResult_NVFATBIN_SUCCESS {
            Ok(())
        } else {
            Err(FatbinError::from(result))
        }
    }

    /// Add a cubin (CUDA binary) to the fatbin.
    ///
    /// # Arguments
    /// * `code` - Raw cubin bytes.
    /// * `arch` - Target architecture (e.g., "sm_75").
    /// * `identifier` - Name for this cubin entry.
    pub fn add_cubin(&mut self, code: &[u8], arch: &str, identifier: &str) -> Result<()> {
        let arch_c = CString::new(arch).map_err(|_| FatbinError::NullPointer)?;
        let ident_c = CString::new(identifier).map_err(|_| FatbinError::NullPointer)?;
        let result = unsafe {
            nvFatbinAddCubin(
                self.handle,
                code.as_ptr() as *const libc::c_void,
                code.len() as libc::size_t,
                arch_c.as_ptr(),
                ident_c.as_ptr(),
            )
        };
        if result == nvFatbinResult_NVFATBIN_SUCCESS {
            Ok(())
        } else {
            Err(FatbinError::from(result))
        }
    }

    /// Add LTOIR to the fatbin.
    ///
    /// # Arguments
    /// * `code` - Raw LTOIR bytes.
    /// * `arch` - Target architecture.
    /// * `identifier` - Name for this entry.
    /// * `options_cmd_line` - Compilation options.
    pub fn add_ltoir(
        &mut self,
        code: &[u8],
        arch: &str,
        identifier: &str,
        options_cmd_line: &str,
    ) -> Result<()> {
        let arch_c = CString::new(arch).map_err(|_| FatbinError::NullPointer)?;
        let ident_c = CString::new(identifier).map_err(|_| FatbinError::NullPointer)?;
        let opts_c = CString::new(options_cmd_line).map_err(|_| FatbinError::NullPointer)?;
        let result = unsafe {
            nvFatbinAddLTOIR(
                self.handle,
                code.as_ptr() as *const libc::c_void,
                code.len() as libc::size_t,
                arch_c.as_ptr(),
                ident_c.as_ptr(),
                opts_c.as_ptr(),
            )
        };
        if result == nvFatbinResult_NVFATBIN_SUCCESS {
            Ok(())
        } else {
            Err(FatbinError::from(result))
        }
    }

    /// Add an index file to the fatbin.
    ///
    /// # Arguments
    /// * `code` - Raw index bytes.
    /// * `identifier` - Name for this entry.
    pub fn add_index(&mut self, code: &[u8], identifier: &str) -> Result<()> {
        let ident_c = CString::new(identifier).map_err(|_| FatbinError::NullPointer)?;
        let result = unsafe {
            nvFatbinAddIndex(
                self.handle,
                code.as_ptr() as *const libc::c_void,
                code.len() as libc::size_t,
                ident_c.as_ptr(),
            )
        };
        if result == nvFatbinResult_NVFATBIN_SUCCESS {
            Ok(())
        } else {
            Err(FatbinError::from(result))
        }
    }

    /// Add relocatable PTX entries from a host object.
    ///
    /// # Arguments
    /// * `code` - Raw host object image.
    pub fn add_reloc(&mut self, code: &[u8]) -> Result<()> {
        let result = unsafe {
            nvFatbinAddReloc(
                self.handle,
                code.as_ptr() as *const libc::c_void,
                code.len() as libc::size_t,
            )
        };
        if result == nvFatbinResult_NVFATBIN_SUCCESS {
            Ok(())
        } else {
            Err(FatbinError::from(result))
        }
    }

    /// Get the size of the final fatbinary in bytes.
    pub fn size(&self) -> Result<usize> {
        let mut size = 0;
        let result = unsafe { nvFatbinSize(self.handle, &mut size) };
        if result == nvFatbinResult_NVFATBIN_SUCCESS {
            Ok(size as usize)
        } else {
            Err(FatbinError::from(result))
        }
    }

    /// Write the final fatbinary into the provided buffer.
    ///
    /// The buffer must be at least as large as the size returned by `size()`.
    pub fn get(&self, buffer: &mut [u8]) -> Result<()> {
        let result = unsafe { nvFatbinGet(self.handle, buffer.as_mut_ptr() as *mut libc::c_void) };
        if result == nvFatbinResult_NVFATBIN_SUCCESS {
            Ok(())
        } else {
            Err(FatbinError::from(result))
        }
    }

    /// Retrieve the fatbinary as a newly allocated vector.
    pub fn to_vec(&self) -> Result<Vec<u8>> {
        let size = self.size()?;
        let mut buffer = vec![0u8; size];
        self.get(&mut buffer)?;
        Ok(buffer)
    }

    /// Get the library version.
    pub fn version() -> Result<(u32, u32)> {
        let mut major = 0;
        let mut minor = 0;
        let result = unsafe { nvFatbinVersion(&mut major, &mut minor) };
        if result == nvFatbinResult_NVFATBIN_SUCCESS {
            Ok((major, minor))
        } else {
            Err(FatbinError::from(result))
        }
    }
}

impl Drop for Fatbin {
    fn drop(&mut self) {
        let mut handle = self.handle;
        let _ = unsafe { nvFatbinDestroy(&mut handle) };
    }
}

// Safe because the handle is opaque and all operations are thread-safe as per the C library.
unsafe impl Send for Fatbin {}
unsafe impl Sync for Fatbin {}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_version() {
        let (major, minor) = Fatbin::version().unwrap();
        // Expect some version, at least 0.0
        println!("nvFatbin version {}.{}", major, minor);
        assert_ne!(major, 0);
    }

    #[test]
    fn test_create_and_destroy() {
        let fatbin = Fatbin::new(&[]);
        assert!(fatbin.is_ok());
        // fatbin dropped automatically
    }

    #[test]
    fn test_add_ptx_error() {
        // Adding empty PTX should produce an error (empty input)
        let mut fatbin = Fatbin::new(&[]).unwrap();
        let result = fatbin.add_ptx("", "sm_75", "test", "");
        assert!(result.is_err());
        // Check error type
        let err = result.unwrap_err();
        match err {
            FatbinError::EmptyInput => (),
            _ => panic!("unexpected error: {:?}", err),
        }
    }

    #[test]
    fn test_size_before_add() {
        let fatbin = Fatbin::new(&[]).unwrap();
        let size = fatbin.size();
        // 16 byte fatbin header
        assert_eq!(size.unwrap(), 16);
    }
}
